# 05. Call Me Maybe

## Entry Point

Рядом с этим документом расположена папка с солюшеном `CallMeMaybe`.

## Монада Maybe

Давай рассмотрим следующую конструкцию - некий обобщенный строго-типизированный контейнер, который либо содержит значение, либо не содержит ничего. В мире функциональных языков такая конструкция известна как монада Maybe. Не будем вдаваться, почему она является монадой. Просто попробуем в качестве тренировки реализовать её и посмотреть, чем она может быть удобна (или наоборот).

В простейшем варианте она могла бы выглядеть примерно так:

```cs
struct Maybe<T>
{
  private T _value;

  public bool HasValue {get; private set;}
  public T Value
  {
    get { return HasValue ? Value : throw new InvalidOperationException()};
  }
}
```

Для ссылочных типов такая конструкция на первый взгляд не особо нужна - там есть выделенное значение `null`, которое позволяет определить, переменная на что-то указывает или нет. У значимых типов такого выделенного значения нет, что и послужило причиной добавления в .Net структуры `Nullable<T>`, которая один в один является монадой Maybe, и ее внутреннее представление так же состоит из двух полей: булева флага `HasValue` и значения `Value`.

Т.е. для ссылочных типов аналога `Maybe` нет, потому что кажется ненужным, а для значимых есть - `Nullable`. Тем не менее иногда хотелось бы:

- иметь один контейнер и для ссылочных, и для значимых типов, который либо `не имеет значения`, либо `имеет not-null значение`.
- расширять только один этот контейнер каким-то необходимым функционалом.

### Пример такого функционала

Лично я знаю и сталкивался лишь с одним примером. Представь, что есть цепочка вычислений, где каждое вычисление может окончиться неудачей, и твоя логика на каждом шаге "если предыдущий шаг был успешен, то выполни следующий". Вроде такого:

```cs
SomeObject Foo(InObj input)
{
  var step1Res = Step1(input);
  if (step1Res != null)
  {
    var step2Res = Step2(step1Res);
    if (step2Res != null)
    {
      // step3 и т.д.
    }
    else {
      // в случае неудачи возможно есть какая-то запасная логика и т.п.
    }
  }
  return null;
}
```

В итоге код обрастает множеством проверок на `null` (с появлением `null propagation` оператора `?.` жизнь стала чуть лучше, но тем не менее) - это может замыливать логику, превращать код в ёлочку со множеством вложенных блоков.

## NaiveChef

Открывай солюшен и открывай файлы `NaiveChef.cs` и `CookingStuff.cs`. В первом файле содержится реализация интерфейса "повар одного рецепта", который по моей задумке должен уметь готовить тыквенные маффины (звучит аппетитно, не правда ли?), что экземпляры `NaiveChef` и делают. Во втором файле - всякая обвязка в виде ингредиентов и кухонной утвари, особо не вникай в него. Однако заметь, что все методы `CookingTable` возвращают `Nullable` типы. Представь, что повар очень нестабилен и находится в очень нестабильной кухне, где успех каждого действия не гарантирован - отсюда возможные `null`-ы.

Вернись в `NaiveChef` и посмотри на алгоритм приготовления маффинов.

## MaybeChef

Теперь открывай `MaybeChef.cs` и посмотри на реализацию того же самого рецепта, но с использованием монады Maybe. Обрати внимание, что 1) никаких явных сравнений с `null` не делается, 2) активно используется LINQ-query синтаксис. Не будем оценивать красоту и понятность данной варианта (это не цель этой лабы), а просто попробуем написать реализацию структуры `Maybe` для поддержки такого варианта.

## Структура `Maybe`

Итак, открывай, наконец, файл `Maybe.cs`. Там ты увидишь заготовку одноименной структуры. Подумай, почему она является структурой, а не классом.

Базовые вещи я реализовал за тебя, чтобы было понятна логика её работы, т.е. что мы от неё вообще хотим. Пока что не обращай внимание на то, что структура является реализацией интерфейса `IEnumerable`.

### Базовый функционал

Базовый функционал будет состоять из оператора неявного приведения к `Maybe<T>`, что позволит, например, писать так:

```cs
Maybe<T> ToMaybe<T>(T value)
{
  return value;
}
```

Реализация оператора приведения должна учитывать, есть ли у переданного объекта значение или он равен `null`, и соответственно либо оборачивать значение в `Maybe`, либо выдавать `Maybe<T>.Nothing`.

Так же базовый функционал будет состоять из класса `MaybeExtensions`, содержащего методы расширения `ToMaybe`, позволяющие объекты любого типа обернуть в `Maybe`. Как думаешь, сколько таких методов нам понадобится? Один очевиден: `ToMaybe<T>: T --> Maybe<T>`. Но со значимыми типами это не всегда будет удобно, если они уже обернуты в `Nullable` - вариант `ToMaybe<T?>: T? --> Maybe<T?>` не очень подходит. Хотелось бы иметь `ToMaybe<T?>: T? --> Maybe<T>`. Итак, метода будет два, попробуй их реализовать.

Можешь закомментировать класс `MaybeChef`, чтобы избавиться от ошибок компиляции и поиграться с имеющейся структурой `Maybe`.

### Подключаем поддержку синтаксиса запросов LINQ

Для того, чтобы можно было использовать `Maybe` в синтаксисе запросов LINQ, необходимо, чтобы структура реализовывала интерфейс `IEnumerable<T>`. Требуемые методы обернуты в соответствующий регион в структуре `Maybe`. Давай реализуем эти методы.

Точнее всего один, второй я реализовал за тебя - это метод `non-generic` интерфейса `IEnumerable`, который нам достался в наследство от первых версий .Net Framework. `Generic` версия интерфейса (интерфейс `IEnumerable<T>`) наследует `non-generic` версию из соображений совместимости (чтобы дженерик версии интерфейсов удовлетворяли и недженерик версиям).

Особо не заморачивайся по этому поводу - как видишь, в `non-generic` методе я просто вызываю `generic` версию метода. Однако обрати внимание на сигнатуру этого метода:

```cs
IEnumerator IEnumerable.GetEnumerator()
```

Это так называемая явная реализация интерфейса. Можешь прочитать про неё на [SO](https://stackoverflow.com/a/4103445/1094048) (см. первые два ответа).

Итак, нужно реализовать метод `GetEnumerator`:

```cs
public IEnumerator<T> GetEnumerator()
```

По смыслу мы хотим наш объект `Maybe` рассматривать как последовательность. Какая она может быть? А вот такая:

- `HasValue == false`: пустая
- `HasValue == true`: из одного элемента `_value`

Пусть тебя не смущает возвращаемый тип `IEnumerator<T>`. Представь, что возвращаемый тип `IEnumerable<T>` - что-то такое ты делал[-а] в 4ой лабе. Оба этих интерфейса конвертируемы друг в друга (и будут). Короче, воспользуйся `yield`-ами.

Если получилось, теперь мы можем писать так:

```cs
var result =
  from x in SomeX().ToMaybe() // код ниже будет выполнен только в случае, если SomeX().ToMaybe() != Maybe<T>.Nothing
  let xx = x * x
  from y in SomeY().ToMaybe() // код ниже будет выполнен только в случае, если и SomeY().ToMaybe() != Maybe<T>.Nothing
  let yy = y * y
  let len = xx + yy
  select len;

// тип переменной result будет IEnumerable<T>, что не очень удобно, но неотвратимо :(

var finalResult = /* retrieve first element or get nothing */;
// finalResult.HasValue == true и _value == len в случае, если и x, и y имели значение, иначе result == Maybe<T>.Nothing
```

Осталось лишь добавить метод-расширение `ToMaybe` в `MaybeExtensions`, который будет разворачивать `IEnumerable<T>` обратно в `Maybe<T>`, т.е.:

`ToMaybe<IEnumerable<T>>: IEnumerable<T> --> Maybe<T>`

Оказывается, это не так удобно, и обычным `FirstOrDefault()` или `SingleOrDefault()` это не сделаешь, т.к. для значимых типов мы не распознаем ситуацию `OrDefault()`. Так что придется поиграться с итераторами - вручную итерироваться на первый элемент и, в случае успеха, собирать `Maybe<T>`, либо отдавать `Maybe<T>.Nothing`. Правда выглядит это так себе, конечно :) 

### В довесок

В регионе `Optional useful methods` структуры `Maybe` ты найдешь еще несколько методов, которые могут быть удобны пользователю этой структуры (в нашей лабе почти ни один из них не используется) - в основном это методы аналоги функции `bind` из мира функциональных языков, которая осуществляет преобразование монад. Давай реализуем и их - надеюсь из названия и сигнатуры методов будет понятно, что требуется.

## И снова `MaybeChef`

Снвова вернемся к нашему незавершенному повару. Теперь, когда структура `Maybe` завершена, код должен компилироваться, и можно реализовать оставшиеся вспомогательные методы `MakeEggsMixture` и `MakeFlourMixture`. Реализуй их по аналогии с реализацией в `NaiveChef`, используя синтаксис запросов LINQ.

Замечание: к сожалению, интерфейс класса `CookingTable` продолжает возвращать `Nullable` типы, поэтому придется явно кастить результаты вызова его методов к `Maybe` - например, с помощью методов-расширений `ToMaybe`.