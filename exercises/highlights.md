# Распространенные ошибки и вещи, на которые стоит обратить внимание

## 01. Primitive Types

### TryParse + throw standard Exception

```cs
/// <summary>
/// Конвертирует строковое представление числа в его 32-битное знаковое целочисленное представление.
/// </summary>
/// <param name="s">Строковое представление числа.</param>
/// <returns>32-битное знаковое целочисленное представление числа.</returns>
internal static int Parse(string s)
{
    /*
        Продолжай идти простым путем -нужен метод, обратный методу ToString выше, который распарсит дефолтное строковое представление числа.
        Подсказка: у каждого примитивного типа есть набор статических методов, среди которых есть нужный.
    */
    int value;
    if (int.TryParse(s, out value)) {
        return value;
    } else {
        throw new ArgumentException("String does not contain correct integer", nameof(s));
    }
}
```

### Compare floats with default epsilon

```cs
/// <summary>
/// Возвращает результат сравнения двух вещественнозначных чисел.
/// </summary>
/// <returns>-1 - первое меньше второго, 0 - значения равны, 1 - первое больше второго.</returns>
internal static int Compare(double firstNumber, double secondNumber, double precision = 0.000001)
```

Одна из самых распространенных ошибок этого задания - снабжать последний аргумент значением по умолчанию. Подумай, почему это неправильно.

Значение по умолчанию может "использоваться всегда, когда нет никаких дополнительных требований". Но чем это значение лучше 1 тысячной или 1 миллиардной? Ты же даже не знаешь заранее какого порядка значения сравниваются. Представь, что пользователь твоего метода использует ее только для сравнения чисел порядка `1E+100`. Разница в порядке сравниваемых чисел и значения `precision` намного длиннее мантиссы, т.е. минимально возможная разница `firstNumber` и `secondNumber` больше `precision`. А это значит, что выражение `|firstNumber - secondNumber| <= precision` равнозначно `|firstNumber - secondNumber| <= 0`, т.е. `firstNumber == secondNumber`. А представь теперь, что числа наоборот порядка `1E-20` - твой метод будет возвращать, что все они равны ;)

Если пользователь разумный и задумался над подходящей для его задачи точностью, то он и так всегда будет передавать свое значение - значение по умолчанию ему будет не нужно. И более того вредно -  если он забудет где-то его передать, то компилятор даже не ругнется, а он будет думать, что везде передал свое правильное значение.
Если же пользователь не задумался об этой проблеме, то он конечно же воспользуется значением по умолчанию, чтобы не напрягаться, и будет ловить интересные ошибки из-за проблем, описанных выше.